/*
 We go through the array, and for each position:
 - Find the smallest element in the remaining unsorted part.
 - Swap it with the current position.
 Keep doing this until the whole array is sorted.

 Time Complexity: O(n^2)
 Space Complexity: O(1)
*/


class Solution {
    public int[] selectionSort(int[] nums) {
        int n = nums.length;

       if (nums == null || nums.length == 0) {
                  return nums;
              }


        // Traverse the array
        for (int i = 0; i < n - 1; i++)                 // i value incremented 
        {
            int minIndex = i;                          // assume current index is minimum

            for (int j = i + 1; j < n; j++)               // Find index of the minimum element in the remaining array
              {  
                if (nums[j] < nums[minIndex]) {
                    minIndex = j;
                }
              }

            if (minIndex != i) {                                //swap the samllest number with the current i index value
                int temp = nums[i];
                nums[i] = nums[minIndex];
                nums[minIndex] = temp;
                }
        }

        return nums;                                    // return sorted array
    }
}



